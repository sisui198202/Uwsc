//------------------配列$

function ArrayCreate(r_fp) //ファイル内テキストを各行をCRで区切り新配列作成fp_配列
	fid= FOpen(r_fp)
	str= FGet(fid, F_ALLTEXT)
	Result=split(str,"<#CR>")
	fclose(fid)
fend

Function ArrayCreate1(str) //各行テキストで配列作成str_配列
	r_fp= "C:\Users\user\Desktop\Verification\abc.txt"
	fid=fopen(r_fp,F_WRITE8 or F_NOCR)
	fput(fid,str)
	fclose(fid)
	hai=ArrayCreate(r_fp)
	Result=hai
Fend


procedure Filter(var arr[], expression) //配列要素から条件抽出し新配列作成_配列
    try
        dummy = arr[0, HASH_EXISTS]
        isHashtbl = TRUE
    except
        isHashtbl = FALSE
    endtry

    if isHashtbl then
        for key in arr
            % = arr[key]
            & = key
            try
                res = eval(expression)
                Select res
                    case TRUE, FALSE
                    default
                        res = TRUE
                selend
            except
                msgbox("不正な式: " + expression + "<#CR>% = " + %)
                exit
            endtry
            if ! res then
                dummy = arr[key, HASH_REMOVE]
            endif
        next
    else
        dim _arr[resize(arr)]
        n = 0
        for % in arr
            try
                res = eval(expression)
                Select res
                    case TRUE, FALSE
                    default
                        res = TRUE
                selend
            except
                msgbox("不正な式: " + expression + "<#CR>% = " + %)
                exit
            endtry
            if res then
                _arr[n] = %
                n = n + 1
            endif
        next
        for i = 0 to resize(arr, n - 1)
            arr[i] = _arr[i]
        next
    endif
fend


procedure Map(var arr[], expression) //各要素1つずつに対して「コールバック関数」を実行し、その結果を新しい配列として返す_配列
    try
        dummy = arr[0, HASH_EXISTS]
        isHashtbl = TRUE
    except
        isHashtbl = FALSE
    endtry

    if isHashtbl then
        dummy = arr[0, HASH_EXISTS]
        for key in arr
            % = arr[key]
            & = key
            try
                arr[key] = eval(expression)
            except
                msgbox("不正な式: " + expression + "<#CR>% = " + %)
                exit
            endtry
        next
    else
        for i = 0 to resize(arr)
            % = arr[i]
            try
                arr[i] = eval(expression)
            except
                msgbox("不正な式: " + expression + "<#CR>% = " + %)
                exit
            endtry
        next
    endif
fend

function ArrSearch(search,r_fp) //ファイル各行を配列で取得、指定単語が含まれていればtrueの1を返す_条件判定
Dim arr = ArrayCreate(r_fp)
for i = 0 to Length(arr)-1
    if search=arr[i] then
        result=true
    else
        continue
    endif
next
fend

function RowSearchArr(r_fp,search,arr[]) //1行ずつsearchを検索し、その前の文字までを配列挿入_配列

	row = GetRow(r_fp)
	i=1
	fid=fopen(r_fp,F_READ)
	resize(arr, row-1)
	z=LENGTH(arr)-1

	for y = 0 to z
		str=fget(fid,i)
		iti=pos(search,str)
		arr[y]=copy(str,1,iti-1)
		i=i+1
	next

	fclose(fid)
	str=join(arr,"<#CR>",true)

	result=split(str,"<#CR>",true)
fend


procedure RowDelimiterArr2Create(r_fp,Delimiter,var arr1[],var arr2[]) //ファイル内行ごと「：」区切って配列を2つ_配列,dim arr1[-1],arr2[-1]で利用可能

str =ReadAlltext(r_fp)

dim i=0

d=GetRow(r_fp)

fid=fopen(r_fp,F_READ)
resize(arr1, d - 1)
resize(arr2, d - 1)

for y = 1 to d
str=fget(fid,y)
arr1[i]=token(Delimiter,str)
arr2[i]=token(Delimiter,str)
i=i+1
next
fclose(fid)
fend


procedure RowDelimiterArr3Create(r_fp,Delimiter,var arr1[],var arr2[],var arr3[]) //ファイル内行ごと：区切って配列を3つ_配列
dim i=0

// dim arr1,arr2,arr3 //既に定義済み
// public arr1,arr2,arr3 //ok
// public arr1[-1],arr2[-1],arr3[-1] //ok
row=GetRow(r_fp)

fid=fopen(r_fp,F_READ)
resize(arr1, row - 1)
resize(arr2, row - 1)
resize(arr3, row - 1)
for y = 1 to row
    row_str=fget(fid,y)
    arr1[i]=token(Delimiter,row_str)
    arr2[i]=token(Delimiter,row_str)
    arr3[i]=token(Delimiter,row_str)
    i=i+1
next
fclose(fid)
fend

function TwoarrToArr(var arr3[][],var arr1[],var arr2[],row) //2次元配列→1次元配列に作成（2つの配列作成）excel行と列_配列
// public arr1,arr2

cou=0
row1=row-1

resize(arr1, row1) //ok
resize(arr2, row1) //ok

// arr1=safearray(0,gyou1) //ng
// arr2=safearray(0,gyou1) //ng

for i = 1 to row
arr1[cou]=arr3[i,1] //[行,列]
arr2[cou]=arr3[i,2]
cou=cou+1
next
result =true
fend



function UBound(arr, d = 1) //Safearrayの上限を得る_配列

def_dll SafeArrayGetUBound(safearray, uint, var long):long:OleAut32
    result = EMPTY
    Select d
        case 1
            result = resize(arr)
        case 2
            if SafeArrayGetUBound( arr, d, result) then result = EMPTY
    selend

fend

function LBound(arr, d = 1) //Safearrayの下限を得る_配列
def_dll SafeArrayGetLBound(safearray, uint, var long):long:OleAut32.dll
    result = EMPTY
    Select d
        case 1
            result = UBound(arr) - length(arr) + 1
        case 2
            if SafeArrayGetLBound( arr, d, result) then result = EMPTY
    selend
fend

Procedure	ReverseArray(var a_Ary[]) //配列を逆順_配列
	Dim i, t, c = Length(a_Ary) - 1
	For i = 0	To Int(c / 2)
		t	= a_Ary[c - i]
		a_Ary[c - i]	= a_Ary[i]
		a_Ary[i]	= t
	Next
FEnd

procedure append(var array[], value) //末尾に値を追加する_配列
		dim new_index = resize(array, length(array))
		array[new_index] = value
fend

FUNCTION append1(var arr[],iti,value) //指定位置に値を追加する_配列
 reSIZE(arr,LENGTH(arr)-1+1)
 IF iti<0 or iti>LENGTH(arr)-1
  arr[LENGTH(arr)-1]=value
 ELSE
  FOR i=LENGTH(arr)-1 TO iti step -1
    IF i=iti
      arr[i]=value
    ELSE
      arr[i]=arr[i-1]
    ENDIF
  NEXT
 ENDIF
 reSULT=1
FEND

procedure ArrCopy(arr[], var copyarr[]) //配列をコピーする_配列
		ifb length(arr) > length(copyarr)
			resize(copyarr, length(arr) - 1)
		endif
		for i = 0 to length(arr) - 1
			copyarr[i] = arr[i]
		next
fend

function ArrContain(arr[], value) //値が含まれているかどうか調べる、含まれている：1　含まれていない：0_配列
    for v in arr
        ifb v = value
            result = true
            exit
        endif
    next
    result = false
fend

FUNCTION ArrRemove(var arr[],iti) //指定位置の要素を削除_配列
   IF iti<0 or iti>LENGTH(arr)-1
            PRINT "無効な要素番号が削除指定されました。"
            reSULT=0
   ELSE
      FOR i=iti TO LENGTH(arr)-1-1
            arr[i]=arr[i+1]
      NEXT
            reSIZE(arr,LENGTH(arr)-1-1)
            reSULT=1
   ENDIF
FEND

function ArrStrDel(arr[],str_del) //指定した配列の要素内から指定の文字列を削除

num1=LENGTH(arr)-1

arr1=safearray(0,num1)
cou=0
for i in arr
arr1[cou]=chgmoj(i, str_del,"")
cou=cou+1
next
result=arr1
fend

function ArrEqual(arr1[], arr2[]) //2つの配列が等しいかどうか調べる2つの配列が等しいのは要素数が同じで、すべての要素が順序通り同じであるときのみ_配列
		ifb length(arr1) <> length(arr2)
			result = false
			exit
		endif
		for i = 0 to length(arr1) - 1
			ifb arr1[i] <> arr2[i]
				result = false
				exit
			endif
		next
		result = true
fend

function ArrBlankAddStr(str,add) //各配列で空欄を指定文字列埋めて、新配列を作成_配列
delimiter="<#CR>"
arr=split(str, delimiter)

len=Length(arr)-1

arr1=safearray(0, len)

for y = 0 to len
arr1[y]=arr[y]
    if arr[y]="" then
    arr1[y]=add
    endif
next
result = arr1
fend


function AddEvenArr(r_fp,even=1) //奇数、偶数配列要素取得
	i=0
	arr=ArrayCreate(r_fp)
	len=LENGTH(arr)
	arr1=SafeArray(0,len)

    FOR　y　=　even　TO　len-1 step 2 //偶数取得成功
    // FOR　y　=　0　TO　len-1 step 2 //奇数取得成功
    arr1[i]=arr[y]
    i=i+1
next

result=arr1
fend

//------------------配列$